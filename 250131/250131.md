# 250131

# 알고리즘 Live 강의

---

## Vector

---

### 배열의 불편한 점

- 사이즈가 정해져 있다.
- 맨 끝의 인덱스의 값을 삭제하고 싶을 때, 뒤의 값을 0으로 만든다.
    
    사이즈는 실제로 10이지만, 현재 들어가 있는 데이터는 “개발자” 입장에서 5개.
    
    → 불-편
    
- 초기화 할 때, for문을 이용해서 배열에 값을 일일이 넣거나
    
    memset을 사용.
    
    > 예고편
    > 
    > 
    > 다음 주 월요일 이 시간!
    > 
    > 9:00 - string
    > 
    > 직업상의 이유로도, A형(adv) 이라는 시험 상의 이유로도, string은 중요도가 매우 떨어진다.
    > 
    > 근데 중요한게, <cstring> 헤더의 memset이 매우 중요.
    > 
    > `memset(arr, 0,sizeof(arr));` 전부 다 0으로 초기화, -1은 되는데 2는 안됨.
    > 

### Vector는 List와 비슷하다.

- Vector는 size가 없다.
    
    값을 넣으면 넣을 수록 그만큼 늘어나고, 값을 빼면 뺄수록 그만큼 줄어든다
    
    → 동적할당
    
- `arr[10] = { 1, 2, 3 };` 이를 출력하고 싶다면?
    
    for문을 쓰고 싶지만, 내가 원하는 size는 과연 항상 3일까?
    

### 메서드와 함수의 차이?

- 클래스 안에 존재하면 메서드.
- Java는 함수가 존재하지 않는다. → 시작부터 클래스.
- C++ 같은 경우는 함수도 존재, 메서드도 존재.

### Vector 안에 들어가는 타입은 서로 일치해야 한다!

- `vector<int> myVec;` 타입을 적는 곳의 꺽쇠는 템플릿이라고도 부름.
- int, char, float 등 정해진 타입뿐만 아니라 구조체도 들어갈 수 있다.
- 구조체는 클래스처럼 객체지향까지 생각해서 항상 첫 문자를 대문자로 작성하자.

### 2차원 Vector

- `vector<vector<int>> v;` 이게 정석이지만 뭔가 복잡해서 안쓰게 됨.
- `vector<int> v[3];` 으로 하면 뭐가 맞을까?
    1. 사이즈가 3인 벡터 1개를 생성하라.
    2. 사이즈가 각각 3인 벡터 3개를 생성하라.
    3. 벡터 3개를 생성하라.  → 3번이 정답!

### 항상 Vector가 배열보다 좋을까?

- 그렇지는 않다.
- 속도인지 메모리인지에 따라 판단해야 한다.
- 웬만해서는 벡터를 쓰지 않는 것을 권장한다.
- 배열보다 느리다.
    
    주소 참조를 통해 따라가는 방식이라 필연적으로 배열보다 느림.
    
- 속도는 배열 vs 메모리는 Vector
- 그러면 벡터를 언제 쓰냐?
    
    → 얼마나 들어갈지 감이 안 잡힐 때.
    

## 방향 배열

---

### 동서남북으로 이동해야 할 때

- 2차원 공간에 어떤 map이 있으면, 캐릭터를 움직여야 할 때 사용.
- `int dy[4] = { -1, 1, 0, 0 };`  `int dx[4] = { 0, 0, -1, 1 }` 상, 하, 좌, 우로 이동.

```cpp
struct Point
{
	int y;
	int x;
};
Point sp = { 1, 1 };

ny = sp.y + dy[i];
nx = sp.x + dx[i];
```

- 좌표 문제가 있으면 위처럼 구조체를 만들고 시작함.

### 범위 밖으로 나간 경우

```cpp
if (ny < 0 || nx < 0 || ny >= 4 || nx >= 4 ) continue;
// && 쓰고 싶으면 범위 안에 있을 때를 고려한다. 아래와 같이...
if (ny >= 0 && ny <= 4 && nx >= 0 && ny <= 4 ) ...
else continue;
```

### 예제 실습

- 내 위치에서 대각선으로 이동한 좌표의 점수를 모두 합한 값을 구하여라

```cpp
#define _CRT_NO_SEQURE_WARNNINGS
#include <iostream>

using namespace std;

struct Point
{
	int y;
	int x;
};

int dy[4] = { -1, 1, 1, -1 };
int dx[4] = { 1, 1, -1, -1 };

int map[4][4] = {
	1, 3, 7, 2,
	2, 2, 6, 1,
	1, 4, 5, 1,
	1, 1, 2, 1,
};

int main()
{
	cin.tie(NULL); ios_base::sync_with_stdio(false);

	Point sp = { 1, 1 };
	int sum = 0;
	int ny;
	int nx;

	for (size_t i = 0; i < 4; i++)
	{
		ny = sp.y + dy[i];
		nx = sp.x + dx[i];
		if (ny < 0 || nx < 0 || ny >= 4 || nx >= 4) continue;
		sum += map[ny][nx];
	}
	
	cout << sum;

	return 0;
}
```

### 코테 팁 : 오만함을 버리자.

1. 방향 배열 할 때, 상하좌우 너무 당연해서 빠르게 치고 넘어가는 경우가 있는데 안된다.
    
    dy, dx가 내가 원하는 방향인지 부터 확인을 하고 들어가자.
    
2. 벽 검증의 경우, 진짜 맞게 썼나 보고 가자.

### 방향 배열에서 짚고 넘어가야 할 것들.

- 반드시 상하좌우는 아니다.
    
    ex) 대각선일 수도?
    
- 4방향이 아닐 수도 있다.
    
    ex) 8방향
    
- 반드시, 한 칸이 아닐 수도 있다.
    
    ex) 장기의 馬는 직진을 한 다음, 대각선으로 진행.
    
- 특정 방향으로 가야할 수도 있음.
    
    ex) 시계방향, 반시계방향
    

→ 즉 방향 배열은 상하좌우 1칸이 아니라, 방향배열은 “가라는 대로 가는 것.”